**Information Technology (IT)**
_Information Technology (IT)_ is the use of computers to store, retrive,
transmit and manipulate data or information, often in the context of a business or the enterprise.

_Technology system (IT system)_ is generally an information system, a communications system or more specially speaking, a computer system - including all hardware, software and peripheral equipment - operated by a limited group of users.
There are haev electronic data processing, among others:
1. Data storage
2. Databases
3. Data retrieval
4. Data transmission
5. Data manipulation

**The difference between Computer Science and Informatics**
_Computer Science_ is study of the theory, experimentation, and engineering that form the basis for the design and use of computers. An alternate, more succinct definition of computer science is the study of automating algorithmic processes that scale. A computer scientist specializes in the theory of computation and the design of computational systems.


_Informatics_ is a branch of information engineering. It involves the practice of information processing and the engineering of information systems, and as an academic field is an applied form of information science. The field considers the interaction between humans and information alongside the construction of interfaces, organisations, technologies and systems.

**Software development**
_Software development_ is the process of conceiving, specifying, designing, programming, documenting, testing and bug fixing involved in creatin and maintaining applications, frameworks or other software components.

_Embedded software development_ that is, the developemnt of emebedded software, such as used for controlling consumer products, requires the development process to be integrated with the development of the controlled physical product.

_Methodologies_
A software development process is framework that is used to structure, plan, and control the process developing informatiion systems. There are several different approaches to software development: _some take a more structured, engineering-based approach to develop business solutions, whereas others may take a more incremental approach, where software evolves as it is developed piece-by-piece._ Most methodologies share some combinatio of the following stages of software development:
1. Analyzing the problem
2. Market research
3. Gathering requirements for the proposed business solution
4. Devising a plan or design for the software-based solution
5. Implementation (coding) of the software
6. testing the software
7. Deployment
8. Maintenance and bug fixing

_Software development activities_
1. Identification of need
	The sources of ideas for software products are plentiful. Software development may involve compromising or going beyond what is required by the client, a software development project may stray into less technical concerns such as human resources, risk management, intellectual property, budgeting, crisis management, etc. These processes may also cause the role of business development to overlap with software development.
2. Planning
	Planning is an objective of each and every activity, where we want to discover things that belong to the project. An important task in creating a software program is extracting the requirements or requirements analysis.
3. Designing
	The design of the software can be established in a software design document. This involves a preliminary or high-level design of the main modules with an overall picture (such as a block diagram) of how the parts fit together. 
4. Implementation, testing and documenting
	Implementation is the part of the process where software engineers actually program the code for the project.
	Software testing is an integral and important phase of the software development process. 
	Documenting the internal design of software for the purpose of future maintenance and enhancement is done throughout development. 
5. Deployment and maintenance
	Deployment starts directly after the code is appropriately tested, approved for release, and sold or otherwise distributed into a production environment. 
	Maintaining and enhancing software to cope with newly discovered faults or requirements can take substantial time and effort, as missed requirements may force redesign of the software.


**Agile Software development**
Agile software development comprises various approaches to software development under which requirements and solutions evolve through the collaborative effort of self-organizing and cross-functional teams and their customer(s)/end user(s). The term agile was popularized, in this context, by the Manifesto for Agile Software Development and there have a values of the seventeen signatories to the manifesto proclaimed that they value:
1. **Individuaks and interactions** over proecess and tools
2. **Working software** over comprehensive documentation
3. **Customer collaboration** over contract negotiation
4. **Responding to Change** over following a plan.
That is to say, the items on the left are valued more than the items on the right. 
As Scott Ambler elucidated:
> Tools and processes are important, but it is more important to have
	competent people working together effectively.
> Good documentation is useful in helping people to understand how the
	software is built and how to use it, but the main point of development is to create software, not documentation.
> A contract is important but is no substitute for working closely with 
	customers to discover what they need.
> A project plan is important, but it must not be too rigid to 
	accommodate changes in technology or the environment, stakeholders' priorities, and people's understanding of the problem and its solution.

_Agile software development principles_

The Manifesto for Agile Software Development is based on twelve principles:

1. Customer satisfaction by early and continuous delivery of valuable 
	software.
2. Welcome changing requirements, even in late development.
3. Deliver working software frequently (weeks rather than months)
4. Close, daily cooperation between business people and developers
5. Projects are built around motivated individuals, who should be 
	trusted
6. Face-to-face conversation is the best form of communication 
	(co-location)
7. Working software is the primary measure of progress
8. Sustainable development, able to maintain a constant pace
9. Continuous attention to technical excellence and good design
10. Simplicity—the art of maximizing the amount of work not done—is 
	essential
11. Best architectures, requirements, and designs emerge from 
	self-organizing teams
12. Regularly, the team reflects on how to become more effective, and 
	adjusts accordingly

**Scrum (software development)**

_Scrum_ is an agile process framework for managing complex knowledge work, with an initial emphasis on software development, although it has been used in other fields and is slowly starting to be explored for other complex work, research and advanced technologies.
Name of _Scrum_ is occaasionally seen written in all-capitals, as SCRUM. The word is not an acronym, so this stylization is not correct; it likely arose due to an early paper by Ken Schwaber which capitalized _Scrum_ in its title.

_Roles_
These are ideally co-located to ensure optimal communication among team members. Together these three roles form the scrum team. There are three roles in the Scrum framework, among others:
1. Product owner
	The product owner, representing the product's stakeholders and the voice of the customer (or may represent the desire of a committe), is responsible for delivering good business results.
2. Development team
	The development team has from three to nine members who carry out all tasks required to build increments of valueable output every sprint.
	While team members are referred to as developers in some literature, the term refers to anyone who plays a role in the development and support of the system or product, and can include research, architects, designers, data spesialists, statisticians, analysts, engineers, programmers, and testers, among others. However, due to the confusion that can arise when some people do not feel the term 'developer' applies to them, they are often referred to just as _team members_.
3. Scrum master
	Scrum is facilitated by a scrum master, who is accountable for removing impediments to the ability of the team to deliver the product goals and deliverables. The scrum master helps to ensure the team follows the agreed processes in the Scrum framework, often facilitates key sessions, and encourages the team to improve. The role has also been referred to as a team facilitator or servant-leader to reinforce these dual perspectives. 
The core responsibilities of a scrum master include (but are not limited to):
1. Helping the product owner maintain the product backlog in a way 
	that ensures the needed work is well understood so the team can continually make forward progress
2. Helping the team to determine the definition of done for the 
	product, with input from key stakeholders
3. Coaching the team, within the Scrum principles, in order to deliver 
	high-quality features for its product[33]
4. Promoting self-organization within the team
5. Helping the scrum team to avoid or remove impediments to its 
	progress, whether internal or external to the team
6. Facilitating team events to ensure regular progress
7. Educating key stakeholders on Agile and Scrum principles
8. Coaching the development team in self-organization and 
	cross-functionality

**Extreme programming**
Extreme programming (XP) is a software development methodology which is intended to improve software quality and responsiveness to changing customer requirements. As a type of agile software development, it advocates frequent "releases" in short development cycles, which is intended to improve productivity and introduce checkpoints at which new customer requirements can be adopted. 

_Concept of Extreme Programming_
1. **Goals**, Extreme Programming Explained describe extreme
	programming as a software-development discipline that organizes people to produce higher-quality software more productively.
2. **Activites**, XP describes four basic activities that are 
	performed within the software development process: coding, testing, listening, and designing. Each of those activities is described below. 
	1. _Coding_, the advocates of XP argue that the only truly 
		important product of the system development process is code – software instructions that a computer can interpret. Without code, there is no working product. Coding can be used to figure out the most suitable solution. Coding can also help to communicate thoughts about programming problems. 
	2. _Testing_, Testing is central to extreme programming.
		Extreme programming's approach is that if a little testing can eliminate a few flaws, a lot of testing can eliminate many more flaws.
		- Unit tests determine whether a given feature works as intended. Programmers write as many automated tests as they can think of that might "break" the code; if all tests run successfully, then the coding is complete. Every piece of code that is written is tested before moving on to the next feature.
		- Acceptance tests verify that the requirements as understood by the programmers satisfy the customer's actual requirements.
	3. _Listening_, Programmers must listen to what the customers need
	 	the system to do, what "business logic" is needed. They must understand these needs well enough to give the customer feedback about the technical aspects of how the problem might be solved, or cannot be solved. Communication between the customer and programmer is further addressed in the planning game.  
	4. 	One could say that system development doesn't need more than 
		coding, testing and listening. If those activities are performed well, the result should always be a system that works.
3. **Values**, Extreme programming initially recognized four values in 
	1999: communication, simplicity, feedback, and courage. A new value, respect, was added in the second edition of Extreme Programming Explained. Those five values are described below. 
	1. _Communication_, Building software systems requires 
		communicating system requirements to the developers of the system. In formal software development methodologies, this task is accomplished through documentation. Extreme programming techniques can be viewed as methods for rapidly building and disseminating institutional knowledge among members of a development team. The goal is to give all developers a shared view of the system which matches the view held by the users of the system. To this end, extreme programming favors simple designs, common metaphors, collaboration of users and programmers, frequent verbal communication, and feedback.
	2. _Simplicity_, Extreme programming encourages starting with the 
		simplest solution. Extra functionality can then be added later. The difference between this approach and more conventional system development methods is the focus on designing and coding for the needs of today instead of those of tomorrow, next week, or next month.
	3. _Feedback_ Within extreme programming, feedback relates to 
		different dimensions of the system development:
    	Feedback from the system: by writing unit tests,[5] or running periodic integration tests, the programmers have direct feedback from the state of the system after implementing changes.
    	Feedback from the customer: The functional tests (aka acceptance tests) are written by the customer and the testers. They will get concrete feedback about the current state of their system. This review is planned once in every two or three weeks so the customer can easily steer the development.
    	Feedback from the team: When customers come up with new requirements in the planning game the team directly gives an estimation of the time that it will take to implement.
    4. _Courage_, Several practices embody courage. One is the 
    	commandment to always design and code for today and not for tomorrow. This is an effort to avoid getting bogged down in design and requiring a lot of effort to implement anything else.
    5. _Respect_, The respect value includes respect for others as 
    	well as self-respect. Programmers should never commit changes that break compilation, that make existing unit-tests fail, or that otherwise delay the work of their peers. Members respect their own work by always striving for high quality and seeking for the best design for the solution at hand through refactoring. 